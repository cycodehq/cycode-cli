from pathlib import Path
from unittest.mock import MagicMock

import pytest
import typer

from cycode.cli.files_collector.sca.python.restore_poetry_dependencies import (
    POETRY_LOCK_FILE_NAME,
    RestorePoetryDependencies,
)
from cycode.cli.models import Document


@pytest.fixture
def mock_ctx(tmp_path: Path) -> typer.Context:
    ctx = MagicMock(spec=typer.Context)
    ctx.obj = {'monitor': False}
    ctx.params = {'path': str(tmp_path)}
    return ctx


@pytest.fixture
def restore_poetry(mock_ctx: typer.Context) -> RestorePoetryDependencies:
    return RestorePoetryDependencies(mock_ctx, is_git_diff=False, command_timeout=30)


class TestIsProject:
    def test_pyproject_toml_with_poetry_lock_matches(
        self, restore_poetry: RestorePoetryDependencies, tmp_path: Path
    ) -> None:
        (tmp_path / 'pyproject.toml').write_text('[tool.poetry]\nname = "test"\n')
        (tmp_path / 'poetry.lock').write_text('# This file is generated by Poetry\n')
        doc = Document(
            str(tmp_path / 'pyproject.toml'),
            '[tool.poetry]\nname = "test"\n',
            absolute_path=str(tmp_path / 'pyproject.toml'),
        )
        assert restore_poetry.is_project(doc) is True

    def test_pyproject_toml_with_tool_poetry_section_matches(
        self, restore_poetry: RestorePoetryDependencies
    ) -> None:
        content = '[tool.poetry]\nname = "my-project"\nversion = "1.0.0"\n'
        doc = Document('pyproject.toml', content)
        assert restore_poetry.is_project(doc) is True

    def test_pyproject_toml_without_poetry_section_does_not_match(
        self, restore_poetry: RestorePoetryDependencies, tmp_path: Path
    ) -> None:
        content = '[build-system]\nrequires = ["setuptools"]\n'
        (tmp_path / 'pyproject.toml').write_text(content)
        doc = Document(
            str(tmp_path / 'pyproject.toml'),
            content,
            absolute_path=str(tmp_path / 'pyproject.toml'),
        )
        assert restore_poetry.is_project(doc) is False

    def test_requirements_txt_does_not_match(self, restore_poetry: RestorePoetryDependencies) -> None:
        doc = Document('requirements.txt', 'requests==2.31.0\n')
        assert restore_poetry.is_project(doc) is False

    def test_setup_py_does_not_match(self, restore_poetry: RestorePoetryDependencies) -> None:
        doc = Document('setup.py', 'from setuptools import setup\nsetup()\n')
        assert restore_poetry.is_project(doc) is False

    def test_empty_content_does_not_match(
        self, restore_poetry: RestorePoetryDependencies, tmp_path: Path
    ) -> None:
        (tmp_path / 'pyproject.toml').write_text('')
        doc = Document(
            str(tmp_path / 'pyproject.toml'),
            '',
            absolute_path=str(tmp_path / 'pyproject.toml'),
        )
        assert restore_poetry.is_project(doc) is False


class TestTryRestoreDependencies:
    def test_existing_poetry_lock_returned_directly(
        self, restore_poetry: RestorePoetryDependencies, tmp_path: Path
    ) -> None:
        lock_content = '# This file is generated by Poetry\n\n[[package]]\nname = "requests"\n'
        (tmp_path / 'pyproject.toml').write_text('[tool.poetry]\nname = "test"\n')
        (tmp_path / 'poetry.lock').write_text(lock_content)

        doc = Document(
            str(tmp_path / 'pyproject.toml'),
            '[tool.poetry]\nname = "test"\n',
            absolute_path=str(tmp_path / 'pyproject.toml'),
        )
        result = restore_poetry.try_restore_dependencies(doc)

        assert result is not None
        assert POETRY_LOCK_FILE_NAME in result.path
        assert result.content == lock_content

    def test_get_lock_file_name(self, restore_poetry: RestorePoetryDependencies) -> None:
        assert restore_poetry.get_lock_file_name() == POETRY_LOCK_FILE_NAME

    def test_get_commands_returns_poetry_lock(self, restore_poetry: RestorePoetryDependencies) -> None:
        commands = restore_poetry.get_commands('/path/to/pyproject.toml')
        assert commands == [['poetry', 'lock']]
