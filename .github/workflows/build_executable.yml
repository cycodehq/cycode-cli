name: Build executable version of CLI

on:
  push:
    branches:
      - main

jobs:
  build:
    strategy:
      fail-fast: false
      matrix:
        os: [ ubuntu-20.04, macos-11, windows-2019 ]

    runs-on: ${{ matrix.os }}

    defaults:
      run:
        shell: bash

    steps:
      - name: Run Cimon
        if: matrix.os == 'ubuntu-20.04'
        uses: cycodelabs/cimon-action@v0
        with:
          client-id: ${{ secrets.CIMON_CLIENT_ID }}
          secret: ${{ secrets.CIMON_SECRET }}
          prevent: true
          allowed-hosts: >
            files.pythonhosted.org
            install.python-poetry.org
            pypi.org

      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Set up Python 3.7
        uses: actions/setup-python@v4
        with:
          python-version: '3.7'

      - name: Load cached Poetry setup
        id: cached-poetry
        uses: actions/cache@v3
        with:
          path: ~/.local
          key: poetry-${{ matrix.os }}-0  # increment to reset cache

      - name: Setup Poetry
        if: steps.cached-poetry.outputs.cache-hit != 'true'
        uses: snok/install-poetry@v1
        with:
          version: 1.5.1

      - name: Add Poetry to PATH
        run: echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Install dependencies
        run: poetry install

      - name: Build executable
        run: poetry run pyinstaller pyinstaller.spec

      - name: Test executable
        run: ./dist/cycode version

      - name: Sign macOS executable
        if: ${{ startsWith(matrix.os, 'macos') }}
        env:
          APPLE_CERT: ${{ secrets.APPLE_CERT }}
          APPLE_CERT_PWD: ${{ secrets.APPLE_CERT_PWD }}
          APPLE_CERT_NAME: ${{ secrets.APPLE_CERT_NAME }}
          APPLE_KEYCHAIN_PASSWORD: ${{ secrets.APPLE_KEYCHAIN_PASSWORD }}
        run: |
          # import certificate
          CERTIFICATE_PATH=$RUNNER_TEMP/build_certificate.p12
          echo -n "$APPLE_CERT" | base64 --decode -o $CERTIFICATE_PATH

          # create temporary keychain
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          security create-keychain -p "$APPLE_KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$APPLE_KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

          # import certificate to keychain
          security import $CERTIFICATE_PATH -P "$APPLE_CERT_PWD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          security list-keychain -d user -s $KEYCHAIN_PATH

          # sign executable
          codesign --deep --force --options=runtime --entitlements entitlements.plist --sign "$APPLE_CERT_NAME" --timestamp dist/cycode

      - name: Notarize macOS executable
        if: ${{ startsWith(matrix.os, 'macos') }}
        env:
          APPLE_NOTARIZATION_EMAIL: ${{ secrets.APPLE_NOTARIZATION_EMAIL }}
          APPLE_NOTARIZATION_PWD: ${{ secrets.APPLE_NOTARIZATION_PWD }}
          APPLE_NOTARIZATION_TEAM_ID: ${{ secrets.APPLE_NOTARIZATION_TEAM_ID }}
        run: |
          # create keychain profile
          xcrun notarytool store-credentials "notarytool-profile" --apple-id "$APPLE_NOTARIZATION_EMAIL" --team-id "$APPLE_NOTARIZATION_TEAM_ID" --password "$APPLE_NOTARIZATION_PWD"

          # create zip file (notarization does not support binaries)
          ditto -c -k --keepParent dist/cycode notarization.zip

          # notarize app (this will take a while)
          xcrun notarytool submit notarization.zip --keychain-profile "notarytool-profile" --wait

          # we can't staple the app because it's executable. we should only staple app bundles like .dmg
          # xcrun stapler staple dist/cycode

      - name: Test macOS signed executable
        if: ${{ startsWith(matrix.os, 'macos') }}
        run: ./dist/cycode version

      - name: Import cert for Windows and setup envs
        if: ${{ startsWith(matrix.os, 'windows') }}
        env:
          SM_CLIENT_CERT_FILE_B64: ${{ secrets.SM_CLIENT_CERT_FILE_B64 }}
        run: |
          # import certificate
          echo "$SM_CLIENT_CERT_FILE_B64" | base64 --decode > /d/Certificate_pkcs12.p12 
          echo "SM_CLIENT_CERT_FILE=D:\\Certificate_pkcs12.p12" >> "$GITHUB_ENV"

          # add required soft to the path
          echo "C:\Program Files (x86)\Windows Kits\10\App Certification Kit" >> $GITHUB_PATH  
          echo "C:\Program Files\DigiCert\DigiCert One Signing Manager Tools" >> $GITHUB_PATH 

      - name: Sign Windows executable
        if: ${{ startsWith(matrix.os, 'windows') }}
        shell: cmd
        env:
          SM_HOST: ${{ secrets.SM_HOST }}
          SM_API_KEY: ${{ secrets.SM_API_KEY }}
          SM_CLIENT_CERT_PASSWORD: ${{ secrets.SM_CLIENT_CERT_PASSWORD }}
          SM_CODE_SIGNING_CERT_SHA1_HASH: ${{ secrets.SM_CODE_SIGNING_CERT_SHA1_HASH }}
        run: |
          :: setup SSM KSP
          curl -X GET  https://one.digicert.com/signingmanager/api-ui/v1/releases/smtools-windows-x64.msi/download -H "x-api-key:%SM_API_KEY%" -o smtools-windows-x64.msi 
          msiexec /i smtools-windows-x64.msi /quiet /qn
          C:\Windows\System32\certutil.exe -csp "DigiCert Signing Manager KSP" -key -user
          smksp_cert_sync.exe

          :: sign executable
          signtool.exe sign /sha1 %SM_CODE_SIGNING_CERT_SHA1_HASH% /tr http://timestamp.digicert.com /td SHA256 /fd SHA256 ".\dist\cycode.exe" 

      - name: Test Windows signed executable
        if: ${{ startsWith(matrix.os, 'windows') }}
        shell: cmd
        run: |
          :: call executable and expect correct output
          .\dist\cycode.exe version

          :: verify signature
          signtool.exe verify /v /pa ".\dist\cycode.exe"

      - uses: actions/upload-artifact@v3
        with:
          name: cycode-cli-${{ matrix.os }}
          path: dist
